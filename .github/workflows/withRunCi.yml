# .github 폴더 생성 후 그 안에 workflows 폴더 생성
# workflows 폴더에 .yml 파일을 생성

# 개발자가 작업이 끝나고 브랜치에 "push" 한다.
name: withRunCi
on: 
  push:
    branches: [dev]

# 코드를 "build"하고 "test" 코드를 통해 검사한다.
jobs:
  run-test:
    name: Run Test
    runs-on: ubuntu-latest
    steps:
    # 저장소에 있는 코드를 ci 서버로 다운로드 받는다
      - name: 1. Get Codes
        uses: actions/checkout@v4

      # 이전에 설치한 파일 캐시하여 사용
      - name: 2. Add Cache
        uses: actions/cache@v4
        id: npm-cache
        with: 
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
      - if: steps.npm-cache.outputs.cache-hit == 'true'
        run: echo 'npm cache hit!'
      - if: steps.npm-cache.outputs.cache-hit != 'true'
        run: echo 'npm cache missed!'

          path:
            ~/.npm
            ${{ github.workspace }}/.next/cache
  # Generate a new cache whenever packages or source files change.
  key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx') }}
  # If source files changed but packages didn't, rebuild from a prior cache.
  restore-keys: |
    ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-

      - name: 3. Install Dependencies
        run: npm ci

        # 테스트 단계를 빌드보다 먼저 실행한 이유는 테스트를 실패한 코드를 빌드할 이유가 없기 때문에(실패하면 이후 단계는 실행되지 않음)
      - name: 4. Run Test
        run: npm run test

      - name: 5. Run Build
        run: npm run build

# 빌드와 테스트가 모두 성공적으로 끝난다면 PR 템플렛을 생성한다.